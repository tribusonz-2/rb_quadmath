# quadmathフロントエンド開発
## チャプター1: 「中身を見る」メソッド

　言語開発は闘争である．リソースとして開発されるには，必ず競合する他者が現れてくる．こうした心理現象では，尊いのを催{くだ}いて卑しいのを入れるというのがある．完成度が不完全であるときには彼らはよほど慢心しているが，完全なときには自ら言葉を失っている．これを見極めた開発者は免許皆伝だろう．  
　乞食な技術者は，卓越した人の拙さに共生しては，可能な限り屈服させてしまおうと考える．これを恐れている債務者は自ら奴隷になっているようなものである．催尊入卑{さいそんにゅうひ}とはいうが，今や尊いものは溶かそう，というアイディアを持った人のメソッドが強い．その動因を調べると，英米型資本主義者らの国際金融資本の展開に因むようだ．彼らはこの世の金融の仕組みを作ったものの，中世から近世に移り変わる次第には名だたる王朝をパージしている．歴史と金融は同じフレームワークだ．筆者は歴史にも精通することになったが，これは公文書として分けるようにした．例の共産主義は，彼らが対抗してもよい資本主義として承認し，政党がこれを採用したものだ．それは，変に/至ってフリーフォームで，気づかないのなら損，という牽引力を持っている．  

　さて，C/C++のコード設計は比較的自由であり，Cではこう書くべしとしていても開発者や文化圏によってアイディアは一つではない．ここで「こう書け」とコーディングルールを提案してきたのがPythonの開発者であり，その機能は規格化された．その名をPEPという．これのおかげで書く基準が一定に保たれるようになった．  
　Pythonはオブジェクト指向言語でありC/C++とはまた別物であるが，ポストC言語としても需要があり，C/C++ファミリの言語の中でも重要な位置づけになりつつある．そのため100％オブジェクト指向言語「ではない」微妙な位置にPythonはある．  
　この100％オブジェクト指向言語は，まつもとゆきひろことMatz氏がPythonからアイディアを得てRubyを生み出したところと一致する．そのためオブジェクト指向言語の規格というと，よりRubyのほうが整然としている．当然，RubyもC/C++ファミリの言語である．ちなみに「日本で唯一の国際水準規格のプログラミング言語」のほうが知名度は高い．将来に向けては，PythonもRubyもそこまで変わらなくなるだろう．  

　筆者曰くだが，オブジェクト指向の数値クラスなどプリミティブ型は，実装として初めて作るメソッド(振る舞い)は「中身を見る」であるに尽きると思う．テスト駆動開発するにしろ，様態がどうなのか分からなくてはいけない．そのため入力するためのメソッドも必要になる．それで開発中なのがool_quad2str()である．  
　メソッドがただ単に「人の見えやすいように表示するための関数」だと考えると，どうして「中身を見る」などと特殊な言い回しで説明するのかと考えることがある．これはオブジェクト指向設計は「全てはオブジェクトである」という設計思想に帰着しているところに尽きている．「オブジェクト」は「振る舞い」が機能の原則であるので，“人の見えやすいように表示する”は振る舞いとは言えない．だから「中身を見る」という遠回しな聞こえのする言い回しをする．とはいえ会話型言語のように，自然でシームレスな開発環境が整うと，これはなんとも当たり前に感じてしまうのである．  

　例えば，Rubyで数値プリミティブ型を作り，`#to_f`メソッドを定義しておき，Mathモジュールの引数に当てると  

```
Math.sqrt(Float128('1.0')) #=> 1.0
Math.sqrt(Float128('1.0')).class #=> Float
```

　暗黙の型変換が実行されている．内部で使われているNUM2DBL()が見慣れのしないクラスが渡された場合，そのクラスに定義されている`#to_f`を参照するため，この「振る舞い」が実現されている．  
　内部的には__float128型からdouble型へ型キャストするだけでよいので，Cでは以下のような書き方となる．  

```
static VALUE
float128_to_f(VALUE self)
{
  __float128 x = GetFloat128(self); // オブジェクトからCの変数に変換する関数を予め作っておく 
  return DBL2NUM((double)x); // double型へ型キャストしつつRubyのFloatへ変換し返す
}
```

　GNUが提供する四倍精度浮動小数点である__float128と，その数学関数であるquadmathライブラリのオブジェクト指向用フロントエンドを作ろうと考えると，この「中身を見るメソッド」が必要になってくる．本題に入る前にこれを紹介したのは，このためである．__float128型はC/C++では浮動小数点規格であるIEEE754を正式採用しており，先述のPythonでもプリミティブ型に指定している．ただし，表示関数はC言語規格として明確に定まっていない．そのためprintf()関数で恒例として中身を確認しようにも，文字化けするか最悪エラーを出す．オブジェクト指向規格としてはool_quad2str()関数はABIにも向くため，おそらくPEPにも取り込まれるだろう．本当は無限大は`Infinity`と表示されるべきだが，PythonはC関数に薄いラッパーをかけているため，Cと同じく`inf`と表示される．  

　宣言は以下．  

```
char ool_quad2str(__float128 x, char format, int *exp, int *sign, char **buf);
```

　関数名はool_*()とした．オブジェクト指向は整数なのか実数なのかを厳密に判定するという点でC/C++の関数とは目的が異なる．そのためオブジェクト指向言語の固有であることを明示し，頭文字を取ってこのプレフィックスがつくようになる．  
　返却値はdtoa()などとは異なり，“変換された書式”である．これは'g'を渡したとき，'e'なのか'f'なのかの判定に役立つ．またこれのため，非数か無限のとき'1'を返却するので，開発者にとって直感的で使いやすい．  
　まだ作りかけなので，仕様は変更するかもしれない．ただ今のところテスト駆動開発はこれで安定している．注目すべきは変換された文字列を渡す引数bufがダブルポインタであるところである．  
　これは返却される文字列が内部の静的クラスを与えた変数へのポインタである．以下のように使う．  

```
__float128 x = 1.0Q;
char *buf;
int exp, sign;
ool_quad2str(x, 'e', &exp, &sign, &buf); // 10進表記．expには0が，signには1が，bufには'1.0'がポインタ渡しされる．
```

　文字列へポインタ渡しするのに`&buf`はあまり見慣れない．シンタックスシュガーで記法が決まっているからである．ただ，引数はダブルポインタであるので，なぜ'&'でポインタ渡ししているのか？の辻褄{つじつま}が見えてくる．文字列の実装には，なにかとバッファ・オーバーランの問題が話題に尽きないが，このやり方は静的クラスを与えた内部変数へのポインタが渡されるので，安全である．  

　なお，送付しているCソースコードではコマンドオプションで確認する．TESTマクロを定義するとルーチンのプロセスが表示される．  

```
$ gcc -o ool_quad2str ool_quad2str.c -lquadmath -DTEST
$ ./ool_quad2str e 1e200 #=> テスト表示される
```

　コメントはなるべく優しく解説するように心がけた．解説は優しさが売りであるということに筆者は気づいたからである．定番のCUIベース動画プレイヤーであるMplayerのマニュアルを参考にすると，なんとなく「分かりました」と忠誠を誓いたくなる．参考にそう説明文を書くと，「優しい」という反応が返ってくる．つまり，適切な解説は優しさに比例している．  
　また，はじめに目につくのは構文の複雑なコンテキストスイッチだろう．全ては数の範囲による．数値プリミティブ型の中身を見るプロセスには，非数かそうでないかからルーチンを取って，次は無限か有限かを判定する．有限だったら0かどうか，0でなかったから10以上かどうか，10以下だったのなら10未満1以上か，1以下なら0~1でスイッチする．符号が正か負かはルーチンとして同じなので，abs()を使い絶対値で判定する．__float128型ではfabsq()がquadmathから提供されている．  
　複素解析{complex analysis}や整数環{integer rings}の話題に移ると，1が如何に整数根{integer root}なのか，常用対数$\log(10)$がなぜ$0.3010\ldots$なのか，など，はたまた解析的整数論など話題に尽きないが，これはそれを初等関数に還元したというのが，いわゆる数学的見解なのである．これは実装アルゴリズムにおける重要な要素であるが，プログラマにとっては数学マニアの“うんちく”に聞こえて仕方がないかもしれない．  

　また10以上のルーチンには非正規化数によるコンパイラの最適化も考慮すべきだろう．(最適化については小冊子が書けそうなほどの規模なのでここでは割愛する)  
　正確に10進に戻せる桁がIEEE754では定められており，__float128型は33である．正規化された最少数より小さい数は，IEEE754の規格では，(数として構成する指数部・仮数部のうち)仮数部の最初の桁を1とするのをやめ，そこを0としてもいいことになっている．これはコンパイラが判断しているところで，その作用は「最適化」という．非正規化数値の最初いくらかの桁は数値を保っているためのもので，四捨五入するかどうかは丸めモードに従いコンパイラが判断する．このため，本当は1e30だが`9.9999....|984|(非正規化数)`のように表示される．数値計算で非正規化数はほとんど必要とされない．オブジェクト指向としても，中身を見るメソッドでもこれは自明である．ただし，書式'f'では非正規化数の可視化も開発者への判断材料に踏まえるべきだろう．また，最適化は，基数が2である以上は，数値計算としても，10以上と1から10の間，1以下とは各々振る舞いが異なっている．これは取り扱いとしても細心の注意が必要である．  

　有効桁数や最適化がもたらしているものは，設計者が捉えようとしているものよりももっと反動的だ．こうなるに決まっているとしても，予想外な振る舞いがある．以下は有効桁数限界のところで，小数点を求めた場合である．(表示結果は開発中のものである)  

```
$ ./ool_quad2str f 5192296858534827628530496329220095.1
  routine: |x| >= 10
  value=5192296858534827628530496329220095.000000000000000000000000000000000
  notation: FP
  case: 10 <= x < 10^FLT128_DIG
  significant digits: integer: 34, fraction: 0
  result:
    format : 'f'
    exp    :  33
    sign   :  1
    value  :  5192296858534827628530496329220095.000000000000000000000000000000000
```

　.1を入力してみたが，実行結果では表現されておらず，四捨五入されているのが分かる．判断材料が決め手となってくるだろう．これは，構文をどうするか開発者自身が事前計画をすることが，前もって重要になってくるということである．  
　以下はフローチャートである．  

```
if x = nan:  goto routine (x = nan)
else:
  if x = inf:  goto routine (x = inf)
  else if |x| = 0:  goto routine (x |x| = 0)
  else if |x| >= 10: goto routine (|x| >= 10)
    if |x| >= 10^FLT128_DIG: goto case (|x| >= 10^FLT128_DIG)
    else if 10 <= |x| < 10^10^FLT128_DIG: goto casse (10 <= |x| < 10^FLT128_DIG)
  else if 1 <= |x| < 10: goto routine (1 <= |x| < 10)
  else if |x| = 1: goto routine (|x| = 1)
  if 0 < |x| < 1: goto routine (0 < |x| < 1)
```

　ここに書式修飾子である'e' 'f' 'g'なども踏まえたルーチンを考えると，やや入り組んだ構文になるだろう．筆者の実装例としては送付Cソースコードのようになった．ソースコードでは過分なゼロを取り除くサブルーチンやラウンドアップ(四捨五入)も組んでいる．なお，サブルーチンを組むのには関数化も考えられるが，「最適化」はある振る舞いにかかるので，如何にラウンドアップとしても全てが同じルーチンではない．(dtoaのソースコードからも参考になるように，)この手のABI関数では関数内でスイッチするなりして一つの構文で完成させるのが一般だろう．多くは可読性{かどくせい}に理由がある．  
　また特筆すべきに，最適化はここでいうルーチンのケースである`(10 <= |x| < 10^FLT128_DIG)`の範囲かつ小数部にはっきりと現れている．  

　有効桁数0の場合，整数部は必然的にFLT128_DIG+1桁になる．  
```
dddddddddddddddddddddddddddddddddd.-
```
　オブジェクト指向の「中身を見る」メソッドでは浮動小数点を表現するものになる．quadmathライブラリ関数であるquadmath_snprintf()では，0が連続して表示される．  
```
// 表示されるべき例
dddddddddddddddddddddddddddddddddd.0
// quadmath_snprintf()の実装例:
dddddddddddddddddddddddddddddddddd.000000000
```
　整数部が1桁以上で有効桁数がFLT128_DIG桁の場合，最適化が加わる．ここで有効桁数はFLT128_DIGより整数部の桁数を引いた数である．それ以下はコンパイラが判断する．  
```
// d := 整数部, f := 小数部, x := 有効桁数以下
// 整数部1桁:
d.fffffffffffffffffffffffffffffffffxxxx...
// 整数部10桁:
dddddddddd.ffffffffffffffffffffffffxxxx...
// 整数部20桁:
dddddddddddddddddddd.ffffffffffffffxxxx...

```
　ついで，0 < x < 1な値の場合，小数点の位は下に下がって0以外の数となったところからFLT128_DIG以下の位を最下位として，小数点第一位から全て有効桁であるので，覚えるべきである．  
```
// 小数点第一位に数がある:
0.fffffffffffffffffffffffffffffffffxxxx...
// 小数点第二位に数がある:
0.0fffffffffffffffffffffffffffffffffxxxx...
// 小数点第十位に数がある:
0.0000000000fffffffffffffffffffffffffffffffffxxxx...
// 0とfは有効桁である
```


　数学では，ある関数の変数の現れる値域を主値{principal value}という．主値は関数によって定義されることも当然のごとく異なっていて，中には定義されない関数もあるだろう．概ね，IEEE754規格で具体的に定義しているところの“主値”はどこかというと，この最適化の加わる“整数部が1桁以上で有効桁数がFLT128_DIG桁以下”だろう．そのため，この範囲では標準ライブラリに用意されているfegetenv()などを使い，規定にしたがって四捨五入するかどうかも考える必要がある．またquadmath_snprintf()などの関数はこの影響を受けているため，環境はライブラリ関数に任せるという手もある．筆者の実装例はこれである．  
　第一位の非正規化数で処理の委任を判断するのが妥当であり，Cでは以下のようにルーチンをスイッチできる．  

```
if (s[denormal_first] == '9') // 第一位の非正規化数が'9'だった場合
{
	s[denormal_first] = 0; // ナル文字にする
	// 四捨五入で丸める
}
else
{
	s[denormal_first] = 0; // ナル文字にする
	if (s[denormal_first-1] == '0') // 有効桁の最後の桁が0だった場合
	{
		// 過分なゼロをストリップする
	}
	else
	{
		// '1'..'9'の場合の処理
	}
}
```

　また主値といっても，全てが同じ特性というわけでもない．整数一桁の最適化についてこれを考えると，それは処理系へ一意に求められている．試しにquadmath_snprintf()に書式`'%Qf'`でいくらか四捨五入寸前の値を入力してみると，以下のようになった．  

```
$ ./ool_quad2str g 1.5999991
  routine: 1 <= |x| < 10
  value=0.160000
  denormalized number first digit: '0'
  result:
    format : 'f'
    exp    :  0
    sign   :  1
    value  :  1.60000
```

　このケースでは，`1.5999991`は小数点第6位で値が'9'なので丸めている．(ちなみに非正規化数ではない)  
　正確な値を求めるルーチンが必要な一方で，どのあたりで丸めるかは，いわゆる処理系定義のようである．  
